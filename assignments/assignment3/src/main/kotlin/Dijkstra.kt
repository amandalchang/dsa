package org.example
class DijkstraShortestPath<VertexType>(private val graph: Graph<VertexType>) {
    /**
     * Finds the shortest path between a given starting vertex and a given
     * destination vertex using Dijkstra's algorithm
     *
     * @param start The starting vertex from which we want to calculate the
     * shortest path
     * @param destination The ending vertex/the vertex we want to get to
     * @return a list of the vertices which will make up the most optimal path
     * based on the costs of the paths between [start] and [destination]
     */
    fun shortestPath(start: VertexType, destination: VertexType): List<VertexType>? {
        val costs = mutableMapOf<VertexType, Double>()
        val prev = mutableMapOf<VertexType, VertexType?>()
        val priorityQueue = MyMinPriorityQueue<VertexType>()

        // Initialize all vertices to have maximum cost and no previous vertices to start
        graph.getVertices().forEach {
            costs[it] = Double.MAX_VALUE
            prev[it] = null
        }

        // The cost to get to the start node should be 0 since we're already there
        costs[start] = 0.0
        priorityQueue.addWithPriority(start, 0.0)

        // Run this loop if the priority queue has anything in it
        while (!priorityQueue.isEmpty()) {
            // If the next value in the priority queue is null, break
            val current = priorityQueue.next() ?: break

            // If we've arrived at the destination, return the path
            if (current == destination) {
                println("We're here kids!")
                return buildPath(start, destination, prev)
            }

            val neighbors = graph.getEdges(current)
            for (neighbor in neighbors.keys) {
                // newDistance is the cost to get to where you are plus the cost to
                // the neighbor in question
                val newDistance = costs[current]!! + neighbors[neighbor]!!
                // update if there's a shorter way to get there
                if (newDistance < costs[neighbor]!!) {
                    costs[neighbor] = newDistance
                    // keeping track of past traversals
                    prev[neighbor] = current
                    // update priority queue with new shorter distance
                    priorityQueue.addWithPriority(neighbor, newDistance)
                }
            }
        }
        // There's nothing left in the priority queue, but we still haven't found
        // a path to the destination, so there is no path at all
        return null
    }

    /**
     * Reconstructs the path that was most optimal to get to the destination
     * once the graph has been fully explored and the shortest path has been
     * computed
     *
     * This function traverses the `previous` map, which contains information
     * about the previous vertex for each vertex in the path, starting from the
     * destination vertex and moving backwards to the starting vertex. It
     * constructs the path by adding each vertex to the `path` list in reverse
     * order.
     *
     * @param start the starting vertex
     * @param destination the ending vertex
     * @param previous A mutable map containing information about the previous
     * vertex for each vertex in the path. This map is generated by Dijkstra's
     * algorithm.
     *
     * @see DijkstraShortestPath.shortestPath
     *
     * Note: This function is tested via testing Dijkstra's algorithm in
     * DijkstraShortestPathTest.kt
     */
    private fun buildPath(
        start: VertexType,
        destination: VertexType,
        previous: MutableMap<VertexType, VertexType?>
    ): List<VertexType> {
        val path = mutableListOf<VertexType>()
        var current: VertexType? = destination
        while (current != null) {
            path.add(current)
            current = previous[current]
        }
        // the path will be backwards, so we'll need to reverse it again
        path.reverse()
        // check to make sure that the first node in the path is the start
        return if (path.first() == start) path else emptyList()
    }
}
